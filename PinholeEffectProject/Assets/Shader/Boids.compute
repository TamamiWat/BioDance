// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SteerForceCalculator //Steer Force
#pragma kernel MotionCalculator //Velocity, Position
#define SIMULATION_BLOCK_SIZE 256 //Size of thread group's thread

struct BoidsData
{
    float3 velocity;
    float3 position;
}

/*
**Buffer Definition
*/
//Boids Data Buffer
StructuredBuffer<BoidsData> _BoidsDataBufferRead;
RWStructuredBuffer<BoidsData> _BoidsDataBufferReadWrite;
//Boids Steer Force Buffer
StructuredBuffer<float3> _BoidsForceBufferRead;
RWStructuredBuffer<float3> _BoidsForceBufferReadWrite;

//From CPU
int m_MaxBoidsObjectNum;
float m_DeltaTime; //Elapsed time from previous frame

//Distance from other objects
float m_CohesionNeighborRadius; //Cohesion
float m_AlignmentNeighborRadius; //Alignment
float m_SeparationNeighborRadius; //Separate

float m_MaxSpeed; //Max Speed
float m_MaxSteerForce; //Max Steer Force
float m_MinSpeed; //Min Speed

//Weights
float m_CohesionWeight; //Cohesion
float m_AlignmentWeight; //Alignment
float m_SeparationWeight; //Separate

float m_AvoidFrameWeight; //Weight for avoiding frame

//Angle with other object
float m_CohesionAngle; //Cohesion
float m_AlignmentAngle; //Alignment
float m_SeparationAngle; //Separate

float4 m_FrameCenter; //center position of frame
float4 m_FrameSize; //frame size

//function
//limit vector size
float3 limit(float3 vec, float max)
{
    float length = sqrt(dot(vec, vec)); //norm : size of vector
    return (length > max && length > 0) ? vec.xyz * (max / length) : vec.xyz;
}

float3 limitVelocity(float3 vec, float max, float min)
{
    float length = sqrt(dot(vec, vec));
    if(length < min)
    {
        vec = vec.xyz * (min / length);
    }
    else if(length > max)
    {
        vec = vec.xyz * (max / length);
    }

    return vec;
}

//return against force when attacked frame
float3 avoidFrame(float3 position)
{
    float3 frameCenter = m_FrameCenter.xyz;
    float3 frameSize = m_FrameSize.xyz;
    float3 againstForce = float3(0, 0, 0);

    //X
    againstForce.x = (position.x < frameCenter.x - frameCenter.x * 0.5) ? againstForce.x + 1.0 : againstForce.x;
    againstForce.x = (position.x > frameCenter.x + frameCenter.x * 0.5) ? againstForce.x - 1.0 : againstForce.x;
    //Y
    againstForce.y = (position.y < frameCenter.y - frameCenter.y * 0.5) ? againstForce.y + 1.0 : againstForce.y;
    againstForce.y = (position.y > frameCenter.y + frameCenter.y * 0.5) ? againstForce.y - 1.0 : againstForce.y;
    //Z
    againstForce.z = (position.z < frameCenter.z - frameCenter.z * 0.5) ? againstForce.z + 1.0 : againstForce.z;
    againstForce.z = (position.z > frameCenter.z + frameCenter.z * 0.5) ? againstForce.z - 1.0 : againstForce.z;

    return againstForce;

}

//Calculate 2vectors angle
float CalculateAngle(float3 vecA, vecB)
{
    float dot = dot(normalize(vecA), normalize(vecB));
    return acos(dot);
}

//shared memory
groupshared BoidsData boids_data[SIMULATION_BLOCK_SIZE] 

//kernel

/*
**SteerForceCalculator
*/
[numthreads(SIMULATION_BLOCK_SIZE,1,1)]
void SteerForceCalculator
 (
    uint3 id : SV_DispatchThreadID, //Unique ID for the entire thread
    uint3 Gid : SV_GroupID,
    uint3 GTid : SV_GroupThreadID,
    uint Gindex : SV_GroupIndex //GroupThreadID in one dimension
)
{
    const unsigned int P_ID = id.x;

    float3 self_Position = _BoidsDataBufferRead[P_ID].position; //position of myself
    float3 self_Velocity = _BoidsForceBufferRead[P_ID].velocity; //velocity of myself

    float3 steer_Force = float3(0, 0, 0); //init steer force

    //counts
    int sepCount = 0; //separation
    int aliCount = 0; //alignment
    int cohCount = 0; //cohesion

    //force result
    float3 sepDirSum = float3(0, 0, 0);//separation
    float3 aliVelSum = float3(0, 0, 0);//alignment
    float3 cohPosSum = float3(0, 0, 0);//cohesion

    for(uint N_block_ID = 0; N_block_ID < (uint)m_MaxBoidsObjectNum; N_block_ID += SIMULATION_BLOCK_SIZE)
    {
        //Storage Boids data in shared memory (Size : SIMULATION_BLOCK_SIZE) 
        boids_data[Gindex] = _BoidsDataBufferRead[N_block_ID + GI];
        
        //Block execution all threds in a group 
        //until all threads in a group reach this call 
        //after sompleting all group shared access
        GroupMemoryBarrierWithGroupSync();

        //calculation with other objects
        for(int N_other_ID = 0; N_other_ID < SIMULATION_BLOCK_SIZE; N_other_ID++)
        {
            float3 other_position = boids_data[N_other_ID].position; //other object position
            float3 other_velocity = boids_data[N_other_ID].velocity; //other object velocity

            //distance and angle with other object
            float3 diff = self_Position - other_position;
            float distance = sqrt(dot(diff, diff));
            float3 angle = (self_Position, other_position);

            //Separation
            if(distance < m_SeparationNeighborRadius && angle < m_SeparationAngle)
            {
                float3 direction = normalize(self_Position - other_position);
                direction /= distance; //Reduce the impact of distant objects
                sepDirSum += direction;
                sepCount++;
            }
            //Alignment
            if(distance < m_AlignmentNeighborRadius && angle < m_AlignmentAngle)
            {
                aliVelSum += other_velocity;
                aliCount++;
            }
            //Cohesion
            if(distance < m_CohesionNeighborRadius && angle < m_CohesionAngle)
            {
                cohPosSum += other_position;
                cohCount++;
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    float3 sepForce = (float3)0.0;
    if(sepCount > 0)
    {
        sepForce = sepDirSum / (float)sepCount; //average
        sepForce = normalize()

        sepForce *= m_SeparationWeight; 

    }

    float3 aliForce = (float3)0.0;
    if(aliCount > 0)
    {
        aliForce = aliVelSum / (float)aliCount;
        aliForce *= m_AlignmentWeight;        
    }

    float3 cohForce = (float3)0.0;
    if(cohCount > 0)
    {
        cohForce = cohPosSum / (float)cohCount;

        cohForce *= m_CohesionWeight;        
    }

    _BoidsForceBufferReadWrite[P_ID] = steer_Force; //update steer force
}

/*
**MotionCalculator
*/
[numthreads(SIMULATION_BLOCK_SIZE,1,1)]
void MotionCalculator
(
    uint3 id : SV_DispatchThreadID
)
{
    const unsigned int P_ID = id.x;    //get index

    BoidsData curentData = _BoidsDataBufferReadWrite[P_ID]; //read current Boids Data
    float3 force = _BoidsForceBufferRead[P_ID]; //read steer force

    curentData.velocity += force * m_DeltaTime; //apply steer force to velocity
    curentData.velocity = limitVelocity(curentData.velocity, m_MaxSpeed, m_MinSpeed);
        //limit velocity
    curentData.position += currentData * m_DeltaTime; //update position

    _BoidsDataBufferReadWrite[P_ID] = currentData; //update Boids data

}